// src/services/github.ts
// Codr â€” Complete GitHub integration for code export and repository management

export interface GitHubConfig {
  token: string;
  username: string;
  email: string;
  repository?: string;
}

export interface GitHubResult {
  success: boolean;
  repositoryUrl?: string;
  commitSha?: string;
  error?: string;
}

export interface RepositoryInfo {
  name: string;
  fullName: string;
  htmlUrl: string;
  sshUrl: string;
  cloneUrl: string;
  defaultBranch: string;
}

export class GitHubService {
  private baseUrl = 'https://api.github.com';

  constructor(private config: GitHubConfig) {}

  async createRepository(
    name: string,
    description: string = '',
    isPrivate: boolean = false,
    template?: string
  ): Promise<GitHubResult & { repository?: RepositoryInfo }> {
    try {
      const response = await fetch(`${this.baseUrl}/user/repos`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${this.config.token}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Codr-Agent/1.0'
        },
        body: JSON.stringify({
          name,
          description: description || `Generated by Codr Agent - ${name}`,
          private: isPrivate,
          auto_init: true,
          gitignore_template: 'Node',
          license_template: 'mit'
        })
      });

      if (!response.ok) {
        const error = await response.json() as any;
        return {
          success: false,
          error: error.message || `Failed to create repository: ${response.status}`
        };
      }

      const repo = await response.json() as any;

      return {
        success: true,
        repositoryUrl: repo.html_url,
        repository: {
          name: repo.name,
          fullName: repo.full_name,
          htmlUrl: repo.html_url,
          sshUrl: repo.ssh_url,
          cloneUrl: repo.clone_url,
          defaultBranch: repo.default_branch
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Network error creating repository'
      };
    }
  }

  async pushFiles(
    repositoryName: string,
    files: Array<{ path: string; content: string }>,
    commitMessage: string = 'Initial commit from Codr Agent',
    branch: string = 'main'
  ): Promise<GitHubResult> {
    try {
      // Get the latest commit SHA for the repository
      const refResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/ref/heads/${branch}`, {
        headers: {
          'Authorization': `token ${this.config.token}`,
          'User-Agent': 'Codr-Agent/1.0'
        }
      });

      if (!refResponse.ok) {
        return {
          success: false,
          error: `Failed to get repository reference: ${refResponse.status}`
        };
      }

      const refData = await refResponse.json() as any;
      const latestCommitSha = refData.object.sha;

      // Get the tree SHA from the latest commit
      const commitResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/commits/${latestCommitSha}`, {
        headers: {
          'Authorization': `token ${this.config.token}`,
          'User-Agent': 'Codr-Agent/1.0'
        }
      });

      if (!commitResponse.ok) {
        return {
          success: false,
          error: `Failed to get commit: ${commitResponse.status}`
        };
      }

      const commitData = await commitResponse.json() as any;
      const treeSha = commitData.tree.sha;

      // Create blobs for each file
      const blobs = await Promise.all(
        files.map(async (file) => {
          const blobResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/blobs`, {
            method: 'POST',
            headers: {
              'Authorization': `token ${this.config.token}`,
              'Content-Type': 'application/json',
              'User-Agent': 'Codr-Agent/1.0'
            },
            body: JSON.stringify({
              content: btoa(file.content), // Base64 encode
              encoding: 'base64'
            })
          });

          if (!blobResponse.ok) {
            throw new Error(`Failed to create blob for ${file.path}: ${blobResponse.status}`);
          }

          const blobData = await blobResponse.json() as any;
          return {
            path: file.path,
            mode: '100644', // Regular file
            type: 'blob',
            sha: blobData.sha
          };
        })
      );

      // Create a new tree
      const treeResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/trees`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${this.config.token}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Codr-Agent/1.0'
        },
        body: JSON.stringify({
          base_tree: treeSha,
          tree: blobs
        })
      });

      if (!treeResponse.ok) {
        return {
          success: false,
          error: `Failed to create tree: ${treeResponse.status}`
        };
      }

      const treeData = await treeResponse.json() as any;

      // Create a new commit
      const newCommitResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/commits`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${this.config.token}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Codr-Agent/1.0'
        },
        body: JSON.stringify({
          message: commitMessage,
          tree: treeData.sha,
          parents: [latestCommitSha]
        })
      });

      if (!newCommitResponse.ok) {
        return {
          success: false,
          error: `Failed to create commit: ${newCommitResponse.status}`
        };
      }

      const newCommitData = await newCommitResponse.json() as any;

      // Update the reference to point to the new commit
      const updateRefResponse = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}/git/refs/heads/${branch}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${this.config.token}`,
          'Content-Type': 'application/json',
          'User-Agent': 'Codr-Agent/1.0'
        },
        body: JSON.stringify({
          sha: newCommitData.sha
        })
      });

      if (!updateRefResponse.ok) {
        return {
          success: false,
          error: `Failed to update reference: ${updateRefResponse.status}`
        };
      }

      return {
        success: true,
        repositoryUrl: `https://github.com/${this.config.username}/${repositoryName}`,
        commitSha: newCommitData.sha
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to push files to repository'
      };
    }
  }

  async getRepository(repositoryName: string): Promise<RepositoryInfo | null> {
    try {
      const response = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}`, {
        headers: {
          'Authorization': `token ${this.config.token}`,
          'User-Agent': 'Codr-Agent/1.0'
        }
      });

      if (!response.ok) {
        return null;
      }

      const repo = await response.json() as any;

      return {
        name: repo.name,
        fullName: repo.full_name,
        htmlUrl: repo.html_url,
        sshUrl: repo.ssh_url,
        cloneUrl: repo.clone_url,
        defaultBranch: repo.default_branch
      };
    } catch (error) {
      return null;
    }
  }

  async deleteRepository(repositoryName: string): Promise<GitHubResult> {
    try {
      const response = await fetch(`${this.baseUrl}/repos/${this.config.username}/${repositoryName}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `token ${this.config.token}`,
          'User-Agent': 'Codr-Agent/1.0'
        }
      });

      if (!response.ok) {
        return {
          success: false,
          error: `Failed to delete repository: ${response.status}`
        };
      }

      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Network error deleting repository'
      };
    }
  }
}

// Factory function
export function createGitHubService(config: GitHubConfig): GitHubService {
  return new GitHubService(config);
}